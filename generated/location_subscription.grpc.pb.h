// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: location_subscription.proto
#ifndef GRPC_location_5fsubscription_2eproto__INCLUDED
#define GRPC_location_5fsubscription_2eproto__INCLUDED

#include "location_subscription.pb.h"

#include <functional>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/server_context.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace location {

class TriggerZoneManager final {
public:
  static constexpr char const *service_full_name() {
    return "location.TriggerZoneManager";
  }
  class StubInterface {
  public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status
    AddZoneTrigger(::grpc::ClientContext *context,
                   const ::location::ZoneTrigger &request,
                   ::location::NewTriggerReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::NewTriggerReply>>
    AsyncAddZoneTrigger(::grpc::ClientContext *context,
                        const ::location::ZoneTrigger &request,
                        ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::NewTriggerReply>>(
          AsyncAddZoneTriggerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::NewTriggerReply>>
    PrepareAsyncAddZoneTrigger(::grpc::ClientContext *context,
                               const ::location::ZoneTrigger &request,
                               ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::NewTriggerReply>>(
          PrepareAsyncAddZoneTriggerRaw(context, request, cq));
    }
    virtual ::grpc::Status
    RemoveZoneTrigger(::grpc::ClientContext *context,
                      const ::location::TriggerId &request,
                      ::location::RemoveTriggerReply *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply>>
    AsyncRemoveZoneTrigger(::grpc::ClientContext *context,
                           const ::location::TriggerId &request,
                           ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::RemoveTriggerReply>>(
          AsyncRemoveZoneTriggerRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply>>
    PrepareAsyncRemoveZoneTrigger(::grpc::ClientContext *context,
                                  const ::location::TriggerId &request,
                                  ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::RemoveTriggerReply>>(
          PrepareAsyncRemoveZoneTriggerRaw(context, request, cq));
    }
    virtual ::grpc::Status
    GetZoneTriggers(::grpc::ClientContext *context,
                    const ::location::Empty &request,
                    ::location::GetZoneTriggersReply *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetZoneTriggersReply>>
    AsyncGetZoneTriggers(::grpc::ClientContext *context,
                         const ::location::Empty &request,
                         ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::GetZoneTriggersReply>>(
          AsyncGetZoneTriggersRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetZoneTriggersReply>>
    PrepareAsyncGetZoneTriggers(::grpc::ClientContext *context,
                                const ::location::Empty &request,
                                ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::GetZoneTriggersReply>>(
          PrepareAsyncGetZoneTriggersRaw(context, request, cq));
    }
    virtual ::grpc::Status
    AddProximityTrigger(::grpc::ClientContext *context,
                        const ::location::ProximityTrigger &request,
                        ::location::NewTriggerReply *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::NewTriggerReply>>
    AsyncAddProximityTrigger(::grpc::ClientContext *context,
                             const ::location::ProximityTrigger &request,
                             ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::NewTriggerReply>>(
          AsyncAddProximityTriggerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::NewTriggerReply>>
    PrepareAsyncAddProximityTrigger(::grpc::ClientContext *context,
                                    const ::location::ProximityTrigger &request,
                                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::NewTriggerReply>>(
          PrepareAsyncAddProximityTriggerRaw(context, request, cq));
    }
    virtual ::grpc::Status
    RemoveProximityTrigger(::grpc::ClientContext *context,
                           const ::location::TriggerId &request,
                           ::location::RemoveTriggerReply *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply>>
    AsyncRemoveProximityTrigger(::grpc::ClientContext *context,
                                const ::location::TriggerId &request,
                                ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::RemoveTriggerReply>>(
          AsyncRemoveProximityTriggerRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply>>
    PrepareAsyncRemoveProximityTrigger(::grpc::ClientContext *context,
                                       const ::location::TriggerId &request,
                                       ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::RemoveTriggerReply>>(
          PrepareAsyncRemoveProximityTriggerRaw(context, request, cq));
    }
    virtual ::grpc::Status
    GetProximityTriggers(::grpc::ClientContext *context,
                         const ::location::Empty &request,
                         ::location::GetProximityTriggersReply *response) = 0;
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetProximityTriggersReply>>
    AsyncGetProximityTriggers(::grpc::ClientContext *context,
                              const ::location::Empty &request,
                              ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::GetProximityTriggersReply>>(
          AsyncGetProximityTriggersRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetProximityTriggersReply>>
    PrepareAsyncGetProximityTriggers(::grpc::ClientContext *context,
                                     const ::location::Empty &request,
                                     ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReaderInterface<
          ::location::GetProximityTriggersReply>>(
          PrepareAsyncGetProximityTriggersRaw(context, request, cq));
    }
    class async_interface {
    public:
      virtual ~async_interface() {}
      virtual void AddZoneTrigger(::grpc::ClientContext *context,
                                  const ::location::ZoneTrigger *request,
                                  ::location::NewTriggerReply *response,
                                  std::function<void(::grpc::Status)>) = 0;
      virtual void AddZoneTrigger(::grpc::ClientContext *context,
                                  const ::location::ZoneTrigger *request,
                                  ::location::NewTriggerReply *response,
                                  ::grpc::ClientUnaryReactor *reactor) = 0;
      virtual void RemoveZoneTrigger(::grpc::ClientContext *context,
                                     const ::location::TriggerId *request,
                                     ::location::RemoveTriggerReply *response,
                                     std::function<void(::grpc::Status)>) = 0;
      virtual void RemoveZoneTrigger(::grpc::ClientContext *context,
                                     const ::location::TriggerId *request,
                                     ::location::RemoveTriggerReply *response,
                                     ::grpc::ClientUnaryReactor *reactor) = 0;
      virtual void GetZoneTriggers(::grpc::ClientContext *context,
                                   const ::location::Empty *request,
                                   ::location::GetZoneTriggersReply *response,
                                   std::function<void(::grpc::Status)>) = 0;
      virtual void GetZoneTriggers(::grpc::ClientContext *context,
                                   const ::location::Empty *request,
                                   ::location::GetZoneTriggersReply *response,
                                   ::grpc::ClientUnaryReactor *reactor) = 0;
      virtual void
      AddProximityTrigger(::grpc::ClientContext *context,
                          const ::location::ProximityTrigger *request,
                          ::location::NewTriggerReply *response,
                          std::function<void(::grpc::Status)>) = 0;
      virtual void
      AddProximityTrigger(::grpc::ClientContext *context,
                          const ::location::ProximityTrigger *request,
                          ::location::NewTriggerReply *response,
                          ::grpc::ClientUnaryReactor *reactor) = 0;
      virtual void
      RemoveProximityTrigger(::grpc::ClientContext *context,
                             const ::location::TriggerId *request,
                             ::location::RemoveTriggerReply *response,
                             std::function<void(::grpc::Status)>) = 0;
      virtual void
      RemoveProximityTrigger(::grpc::ClientContext *context,
                             const ::location::TriggerId *request,
                             ::location::RemoveTriggerReply *response,
                             ::grpc::ClientUnaryReactor *reactor) = 0;
      virtual void
      GetProximityTriggers(::grpc::ClientContext *context,
                           const ::location::Empty *request,
                           ::location::GetProximityTriggersReply *response,
                           std::function<void(::grpc::Status)>) = 0;
      virtual void
      GetProximityTriggers(::grpc::ClientContext *context,
                           const ::location::Empty *request,
                           ::location::GetProximityTriggersReply *response,
                           ::grpc::ClientUnaryReactor *reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface *async() { return nullptr; }
    class async_interface *experimental_async() {
      return async();
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::NewTriggerReply> *
    AsyncAddZoneTriggerRaw(::grpc::ClientContext *context,
                           const ::location::ZoneTrigger &request,
                           ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::NewTriggerReply> *
    PrepareAsyncAddZoneTriggerRaw(::grpc::ClientContext *context,
                                  const ::location::ZoneTrigger &request,
                                  ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply> *
    AsyncRemoveZoneTriggerRaw(::grpc::ClientContext *context,
                              const ::location::TriggerId &request,
                              ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply> *
    PrepareAsyncRemoveZoneTriggerRaw(::grpc::ClientContext *context,
                                     const ::location::TriggerId &request,
                                     ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetZoneTriggersReply> *
    AsyncGetZoneTriggersRaw(::grpc::ClientContext *context,
                            const ::location::Empty &request,
                            ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetZoneTriggersReply> *
    PrepareAsyncGetZoneTriggersRaw(::grpc::ClientContext *context,
                                   const ::location::Empty &request,
                                   ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::NewTriggerReply> *
    AsyncAddProximityTriggerRaw(::grpc::ClientContext *context,
                                const ::location::ProximityTrigger &request,
                                ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::NewTriggerReply> *
    PrepareAsyncAddProximityTriggerRaw(
        ::grpc::ClientContext *context,
        const ::location::ProximityTrigger &request,
        ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply> *
    AsyncRemoveProximityTriggerRaw(::grpc::ClientContext *context,
                                   const ::location::TriggerId &request,
                                   ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::RemoveTriggerReply> *
    PrepareAsyncRemoveProximityTriggerRaw(::grpc::ClientContext *context,
                                          const ::location::TriggerId &request,
                                          ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetProximityTriggersReply> *
    AsyncGetProximityTriggersRaw(::grpc::ClientContext *context,
                                 const ::location::Empty &request,
                                 ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<
        ::location::GetProximityTriggersReply> *
    PrepareAsyncGetProximityTriggersRaw(::grpc::ClientContext *context,
                                        const ::location::Empty &request,
                                        ::grpc::CompletionQueue *cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
         const ::grpc::StubOptions &options = ::grpc::StubOptions());
    ::grpc::Status
    AddZoneTrigger(::grpc::ClientContext *context,
                   const ::location::ZoneTrigger &request,
                   ::location::NewTriggerReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>
    AsyncAddZoneTrigger(::grpc::ClientContext *context,
                        const ::location::ZoneTrigger &request,
                        ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>(
          AsyncAddZoneTriggerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>
    PrepareAsyncAddZoneTrigger(::grpc::ClientContext *context,
                               const ::location::ZoneTrigger &request,
                               ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>(
          PrepareAsyncAddZoneTriggerRaw(context, request, cq));
    }
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ClientContext *context,
                      const ::location::TriggerId &request,
                      ::location::RemoveTriggerReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>
    AsyncRemoveZoneTrigger(::grpc::ClientContext *context,
                           const ::location::TriggerId &request,
                           ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>(
          AsyncRemoveZoneTriggerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>
    PrepareAsyncRemoveZoneTrigger(::grpc::ClientContext *context,
                                  const ::location::TriggerId &request,
                                  ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>(
          PrepareAsyncRemoveZoneTriggerRaw(context, request, cq));
    }
    ::grpc::Status
    GetZoneTriggers(::grpc::ClientContext *context,
                    const ::location::Empty &request,
                    ::location::GetZoneTriggersReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::GetZoneTriggersReply>>
    AsyncGetZoneTriggers(::grpc::ClientContext *context,
                         const ::location::Empty &request,
                         ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::GetZoneTriggersReply>>(
          AsyncGetZoneTriggersRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::GetZoneTriggersReply>>
    PrepareAsyncGetZoneTriggers(::grpc::ClientContext *context,
                                const ::location::Empty &request,
                                ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::GetZoneTriggersReply>>(
          PrepareAsyncGetZoneTriggersRaw(context, request, cq));
    }
    ::grpc::Status
    AddProximityTrigger(::grpc::ClientContext *context,
                        const ::location::ProximityTrigger &request,
                        ::location::NewTriggerReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>
    AsyncAddProximityTrigger(::grpc::ClientContext *context,
                             const ::location::ProximityTrigger &request,
                             ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>(
          AsyncAddProximityTriggerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>
    PrepareAsyncAddProximityTrigger(::grpc::ClientContext *context,
                                    const ::location::ProximityTrigger &request,
                                    ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply>>(
          PrepareAsyncAddProximityTriggerRaw(context, request, cq));
    }
    ::grpc::Status
    RemoveProximityTrigger(::grpc::ClientContext *context,
                           const ::location::TriggerId &request,
                           ::location::RemoveTriggerReply *response) override;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>
    AsyncRemoveProximityTrigger(::grpc::ClientContext *context,
                                const ::location::TriggerId &request,
                                ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>(
          AsyncRemoveProximityTriggerRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>
    PrepareAsyncRemoveProximityTrigger(::grpc::ClientContext *context,
                                       const ::location::TriggerId &request,
                                       ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply>>(
          PrepareAsyncRemoveProximityTriggerRaw(context, request, cq));
    }
    ::grpc::Status GetProximityTriggers(
        ::grpc::ClientContext *context, const ::location::Empty &request,
        ::location::GetProximityTriggersReply *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<
        ::location::GetProximityTriggersReply>>
    AsyncGetProximityTriggers(::grpc::ClientContext *context,
                              const ::location::Empty &request,
                              ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<
          ::location::GetProximityTriggersReply>>(
          AsyncGetProximityTriggersRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<
        ::location::GetProximityTriggersReply>>
    PrepareAsyncGetProximityTriggers(::grpc::ClientContext *context,
                                     const ::location::Empty &request,
                                     ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<::grpc::ClientAsyncResponseReader<
          ::location::GetProximityTriggersReply>>(
          PrepareAsyncGetProximityTriggersRaw(context, request, cq));
    }
    class async final : public StubInterface::async_interface {
    public:
      void AddZoneTrigger(::grpc::ClientContext *context,
                          const ::location::ZoneTrigger *request,
                          ::location::NewTriggerReply *response,
                          std::function<void(::grpc::Status)>) override;
      void AddZoneTrigger(::grpc::ClientContext *context,
                          const ::location::ZoneTrigger *request,
                          ::location::NewTriggerReply *response,
                          ::grpc::ClientUnaryReactor *reactor) override;
      void RemoveZoneTrigger(::grpc::ClientContext *context,
                             const ::location::TriggerId *request,
                             ::location::RemoveTriggerReply *response,
                             std::function<void(::grpc::Status)>) override;
      void RemoveZoneTrigger(::grpc::ClientContext *context,
                             const ::location::TriggerId *request,
                             ::location::RemoveTriggerReply *response,
                             ::grpc::ClientUnaryReactor *reactor) override;
      void GetZoneTriggers(::grpc::ClientContext *context,
                           const ::location::Empty *request,
                           ::location::GetZoneTriggersReply *response,
                           std::function<void(::grpc::Status)>) override;
      void GetZoneTriggers(::grpc::ClientContext *context,
                           const ::location::Empty *request,
                           ::location::GetZoneTriggersReply *response,
                           ::grpc::ClientUnaryReactor *reactor) override;
      void AddProximityTrigger(::grpc::ClientContext *context,
                               const ::location::ProximityTrigger *request,
                               ::location::NewTriggerReply *response,
                               std::function<void(::grpc::Status)>) override;
      void AddProximityTrigger(::grpc::ClientContext *context,
                               const ::location::ProximityTrigger *request,
                               ::location::NewTriggerReply *response,
                               ::grpc::ClientUnaryReactor *reactor) override;
      void RemoveProximityTrigger(::grpc::ClientContext *context,
                                  const ::location::TriggerId *request,
                                  ::location::RemoveTriggerReply *response,
                                  std::function<void(::grpc::Status)>) override;
      void RemoveProximityTrigger(::grpc::ClientContext *context,
                                  const ::location::TriggerId *request,
                                  ::location::RemoveTriggerReply *response,
                                  ::grpc::ClientUnaryReactor *reactor) override;
      void GetProximityTriggers(::grpc::ClientContext *context,
                                const ::location::Empty *request,
                                ::location::GetProximityTriggersReply *response,
                                std::function<void(::grpc::Status)>) override;
      void GetProximityTriggers(::grpc::ClientContext *context,
                                const ::location::Empty *request,
                                ::location::GetProximityTriggersReply *response,
                                ::grpc::ClientUnaryReactor *reactor) override;

    private:
      friend class Stub;
      explicit async(Stub *stub) : stub_(stub) {}
      Stub *stub() { return stub_; }
      Stub *stub_;
    };
    class async *async() override {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class async async_stub_ {
      this
    };
    ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply> *
    AsyncAddZoneTriggerRaw(::grpc::ClientContext *context,
                           const ::location::ZoneTrigger &request,
                           ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply> *
    PrepareAsyncAddZoneTriggerRaw(::grpc::ClientContext *context,
                                  const ::location::ZoneTrigger &request,
                                  ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply> *
    AsyncRemoveZoneTriggerRaw(::grpc::ClientContext *context,
                              const ::location::TriggerId &request,
                              ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply> *
    PrepareAsyncRemoveZoneTriggerRaw(::grpc::ClientContext *context,
                                     const ::location::TriggerId &request,
                                     ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::GetZoneTriggersReply> *
    AsyncGetZoneTriggersRaw(::grpc::ClientContext *context,
                            const ::location::Empty &request,
                            ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::GetZoneTriggersReply> *
    PrepareAsyncGetZoneTriggersRaw(::grpc::ClientContext *context,
                                   const ::location::Empty &request,
                                   ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply> *
    AsyncAddProximityTriggerRaw(::grpc::ClientContext *context,
                                const ::location::ProximityTrigger &request,
                                ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::NewTriggerReply> *
    PrepareAsyncAddProximityTriggerRaw(
        ::grpc::ClientContext *context,
        const ::location::ProximityTrigger &request,
        ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply> *
    AsyncRemoveProximityTriggerRaw(::grpc::ClientContext *context,
                                   const ::location::TriggerId &request,
                                   ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::RemoveTriggerReply> *
    PrepareAsyncRemoveProximityTriggerRaw(::grpc::ClientContext *context,
                                          const ::location::TriggerId &request,
                                          ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::GetProximityTriggersReply> *
    AsyncGetProximityTriggersRaw(::grpc::ClientContext *context,
                                 const ::location::Empty &request,
                                 ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::GetProximityTriggersReply> *
    PrepareAsyncGetProximityTriggersRaw(::grpc::ClientContext *context,
                                        const ::location::Empty &request,
                                        ::grpc::CompletionQueue *cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_AddZoneTrigger_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveZoneTrigger_;
    const ::grpc::internal::RpcMethod rpcmethod_GetZoneTriggers_;
    const ::grpc::internal::RpcMethod rpcmethod_AddProximityTrigger_;
    const ::grpc::internal::RpcMethod rpcmethod_RemoveProximityTrigger_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProximityTriggers_;
  };
  static std::unique_ptr<Stub>
  NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
          const ::grpc::StubOptions &options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext *context,
                   const ::location::ZoneTrigger *request,
                   ::location::NewTriggerReply *response);
    virtual ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext *context,
                      const ::location::TriggerId *request,
                      ::location::RemoveTriggerReply *response);
    virtual ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext *context,
                    const ::location::Empty *request,
                    ::location::GetZoneTriggersReply *response);
    virtual ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext *context,
                        const ::location::ProximityTrigger *request,
                        ::location::NewTriggerReply *response);
    virtual ::grpc::Status
    RemoveProximityTrigger(::grpc::ServerContext *context,
                           const ::location::TriggerId *request,
                           ::location::RemoveTriggerReply *response);
    virtual ::grpc::Status
    GetProximityTriggers(::grpc::ServerContext *context,
                         const ::location::Empty *request,
                         ::location::GetProximityTriggersReply *response);
  };
  template <class BaseClass>
  class WithAsyncMethod_AddZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_AddZoneTrigger() { ::grpc::Service::MarkMethodAsync(0); }
    ~WithAsyncMethod_AddZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddZoneTrigger(
        ::grpc::ServerContext *context, ::location::ZoneTrigger *request,
        ::grpc::ServerAsyncResponseWriter<::location::NewTriggerReply>
            *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_RemoveZoneTrigger() { ::grpc::Service::MarkMethodAsync(1); }
    ~WithAsyncMethod_RemoveZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveZoneTrigger(
        ::grpc::ServerContext *context, ::location::TriggerId *request,
        ::grpc::ServerAsyncResponseWriter<::location::RemoveTriggerReply>
            *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetZoneTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_GetZoneTriggers() { ::grpc::Service::MarkMethodAsync(2); }
    ~WithAsyncMethod_GetZoneTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetZoneTriggers(
        ::grpc::ServerContext *context, ::location::Empty *request,
        ::grpc::ServerAsyncResponseWriter<::location::GetZoneTriggersReply>
            *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_AddProximityTrigger() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_AddProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddProximityTrigger(
        ::grpc::ServerContext *context, ::location::ProximityTrigger *request,
        ::grpc::ServerAsyncResponseWriter<::location::NewTriggerReply>
            *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RemoveProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_RemoveProximityTrigger() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_RemoveProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveProximityTrigger(
        ::grpc::ServerContext * /*context*/,
        const ::location::TriggerId * /*request*/,
        ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveProximityTrigger(
        ::grpc::ServerContext *context, ::location::TriggerId *request,
        ::grpc::ServerAsyncResponseWriter<::location::RemoveTriggerReply>
            *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProximityTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_GetProximityTriggers() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetProximityTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProximityTriggers(
        ::grpc::ServerContext * /*context*/,
        const ::location::Empty * /*request*/,
        ::location::GetProximityTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProximityTriggers(
        ::grpc::ServerContext *context, ::location::Empty *request,
        ::grpc::ServerAsyncResponseWriter<::location::GetProximityTriggersReply>
            *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_AddZoneTrigger<WithAsyncMethod_RemoveZoneTrigger<
      WithAsyncMethod_GetZoneTriggers<WithAsyncMethod_AddProximityTrigger<
          WithAsyncMethod_RemoveProximityTrigger<
              WithAsyncMethod_GetProximityTriggers<Service>>>>>>
      AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_AddZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_AddZoneTrigger() {
      ::grpc::Service::MarkMethodCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<
                 ::location::ZoneTrigger, ::location::NewTriggerReply>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::ZoneTrigger *request,
                        ::location::NewTriggerReply *response) {
                   return this->AddZoneTrigger(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_AddZoneTrigger(
        ::grpc::MessageAllocator<::location::ZoneTrigger,
                                 ::location::NewTriggerReply> *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::location::ZoneTrigger, ::location::NewTriggerReply> *>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    AddZoneTrigger(::grpc::CallbackServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_RemoveZoneTrigger() {
      ::grpc::Service::MarkMethodCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<
                 ::location::TriggerId, ::location::RemoveTriggerReply>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::TriggerId *request,
                        ::location::RemoveTriggerReply *response) {
                   return this->RemoveZoneTrigger(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_RemoveZoneTrigger(
        ::grpc::MessageAllocator<::location::TriggerId,
                                 ::location::RemoveTriggerReply> *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::location::TriggerId, ::location::RemoveTriggerReply> *>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    RemoveZoneTrigger(::grpc::CallbackServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetZoneTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_GetZoneTriggers() {
      ::grpc::Service::MarkMethodCallback(
          2, new ::grpc::internal::CallbackUnaryHandler<
                 ::location::Empty, ::location::GetZoneTriggersReply>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::Empty *request,
                        ::location::GetZoneTriggersReply *response) {
                   return this->GetZoneTriggers(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_GetZoneTriggers(
        ::grpc::MessageAllocator<::location::Empty,
                                 ::location::GetZoneTriggersReply> *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::location::Empty, ::location::GetZoneTriggersReply> *>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetZoneTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    GetZoneTriggers(::grpc::CallbackServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_AddProximityTrigger() {
      ::grpc::Service::MarkMethodCallback(
          3, new ::grpc::internal::CallbackUnaryHandler<
                 ::location::ProximityTrigger, ::location::NewTriggerReply>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::ProximityTrigger *request,
                        ::location::NewTriggerReply *response) {
                   return this->AddProximityTrigger(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_AddProximityTrigger(
        ::grpc::MessageAllocator<::location::ProximityTrigger,
                                 ::location::NewTriggerReply> *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::location::ProximityTrigger, ::location::NewTriggerReply> *>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    AddProximityTrigger(::grpc::CallbackServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_RemoveProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_RemoveProximityTrigger() {
      ::grpc::Service::MarkMethodCallback(
          4, new ::grpc::internal::CallbackUnaryHandler<
                 ::location::TriggerId, ::location::RemoveTriggerReply>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::TriggerId *request,
                        ::location::RemoveTriggerReply *response) {
                   return this->RemoveProximityTrigger(context, request,
                                                       response);
                 }));
    }
    void SetMessageAllocatorFor_RemoveProximityTrigger(
        ::grpc::MessageAllocator<::location::TriggerId,
                                 ::location::RemoveTriggerReply> *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::location::TriggerId, ::location::RemoveTriggerReply> *>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RemoveProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveProximityTrigger(
        ::grpc::ServerContext * /*context*/,
        const ::location::TriggerId * /*request*/,
        ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    RemoveProximityTrigger(::grpc::CallbackServerContext * /*context*/,
                           const ::location::TriggerId * /*request*/,
                           ::location::RemoveTriggerReply * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetProximityTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_GetProximityTriggers() {
      ::grpc::Service::MarkMethodCallback(
          5, new ::grpc::internal::CallbackUnaryHandler<
                 ::location::Empty, ::location::GetProximityTriggersReply>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::Empty *request,
                        ::location::GetProximityTriggersReply *response) {
                   return this->GetProximityTriggers(context, request,
                                                     response);
                 }));
    }
    void SetMessageAllocatorFor_GetProximityTriggers(
        ::grpc::MessageAllocator<::location::Empty,
                                 ::location::GetProximityTriggersReply>
            *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler<
          ::location::Empty, ::location::GetProximityTriggersReply> *>(handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetProximityTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProximityTriggers(
        ::grpc::ServerContext * /*context*/,
        const ::location::Empty * /*request*/,
        ::location::GetProximityTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    GetProximityTriggers(::grpc::CallbackServerContext * /*context*/,
                         const ::location::Empty * /*request*/,
                         ::location::GetProximityTriggersReply * /*response*/) {
      return nullptr;
    }
  };
  typedef WithCallbackMethod_AddZoneTrigger<
      WithCallbackMethod_RemoveZoneTrigger<WithCallbackMethod_GetZoneTriggers<
          WithCallbackMethod_AddProximityTrigger<
              WithCallbackMethod_RemoveProximityTrigger<
                  WithCallbackMethod_GetProximityTriggers<Service>>>>>>
      CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_AddZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_AddZoneTrigger() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_AddZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_RemoveZoneTrigger() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_RemoveZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetZoneTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_GetZoneTriggers() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetZoneTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_AddProximityTrigger() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_AddProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RemoveProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_RemoveProximityTrigger() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_RemoveProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveProximityTrigger(
        ::grpc::ServerContext * /*context*/,
        const ::location::TriggerId * /*request*/,
        ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProximityTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_GetProximityTriggers() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetProximityTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProximityTriggers(
        ::grpc::ServerContext * /*context*/,
        const ::location::Empty * /*request*/,
        ::location::GetProximityTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_AddZoneTrigger() { ::grpc::Service::MarkMethodRaw(0); }
    ~WithRawMethod_AddZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddZoneTrigger(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_RemoveZoneTrigger() { ::grpc::Service::MarkMethodRaw(1); }
    ~WithRawMethod_RemoveZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveZoneTrigger(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetZoneTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_GetZoneTriggers() { ::grpc::Service::MarkMethodRaw(2); }
    ~WithRawMethod_GetZoneTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetZoneTriggers(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_AddProximityTrigger() { ::grpc::Service::MarkMethodRaw(3); }
    ~WithRawMethod_AddProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddProximityTrigger(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RemoveProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_RemoveProximityTrigger() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_RemoveProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveProximityTrigger(
        ::grpc::ServerContext * /*context*/,
        const ::location::TriggerId * /*request*/,
        ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRemoveProximityTrigger(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetProximityTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_GetProximityTriggers() { ::grpc::Service::MarkMethodRaw(5); }
    ~WithRawMethod_GetProximityTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProximityTriggers(
        ::grpc::ServerContext * /*context*/,
        const ::location::Empty * /*request*/,
        ::location::GetProximityTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProximityTriggers(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_AddZoneTrigger() {
      ::grpc::Service::MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->AddZoneTrigger(context, request, response);
                 }));
    }
    ~WithRawCallbackMethod_AddZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    AddZoneTrigger(::grpc::CallbackServerContext * /*context*/,
                   const ::grpc::ByteBuffer * /*request*/,
                   ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_RemoveZoneTrigger() {
      ::grpc::Service::MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->RemoveZoneTrigger(context, request, response);
                 }));
    }
    ~WithRawCallbackMethod_RemoveZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    RemoveZoneTrigger(::grpc::CallbackServerContext * /*context*/,
                      const ::grpc::ByteBuffer * /*request*/,
                      ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetZoneTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_GetZoneTriggers() {
      ::grpc::Service::MarkMethodRawCallback(
          2, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->GetZoneTriggers(context, request, response);
                 }));
    }
    ~WithRawCallbackMethod_GetZoneTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    GetZoneTriggers(::grpc::CallbackServerContext * /*context*/,
                    const ::grpc::ByteBuffer * /*request*/,
                    ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_AddProximityTrigger() {
      ::grpc::Service::MarkMethodRawCallback(
          3, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->AddProximityTrigger(context, request, response);
                 }));
    }
    ~WithRawCallbackMethod_AddProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    AddProximityTrigger(::grpc::CallbackServerContext * /*context*/,
                        const ::grpc::ByteBuffer * /*request*/,
                        ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RemoveProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_RemoveProximityTrigger() {
      ::grpc::Service::MarkMethodRawCallback(
          4, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->RemoveProximityTrigger(context, request,
                                                       response);
                 }));
    }
    ~WithRawCallbackMethod_RemoveProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RemoveProximityTrigger(
        ::grpc::ServerContext * /*context*/,
        const ::location::TriggerId * /*request*/,
        ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    RemoveProximityTrigger(::grpc::CallbackServerContext * /*context*/,
                           const ::grpc::ByteBuffer * /*request*/,
                           ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetProximityTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_GetProximityTriggers() {
      ::grpc::Service::MarkMethodRawCallback(
          5, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->GetProximityTriggers(context, request,
                                                     response);
                 }));
    }
    ~WithRawCallbackMethod_GetProximityTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProximityTriggers(
        ::grpc::ServerContext * /*context*/,
        const ::location::Empty * /*request*/,
        ::location::GetProximityTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    GetProximityTriggers(::grpc::CallbackServerContext * /*context*/,
                         const ::grpc::ByteBuffer * /*request*/,
                         ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_AddZoneTrigger() {
      ::grpc::Service::MarkMethodStreamed(
          0, new ::grpc::internal::StreamedUnaryHandler<
                 ::location::ZoneTrigger, ::location::NewTriggerReply>(
                 [this](::grpc::ServerContext *context,
                        ::grpc::ServerUnaryStreamer<::location::ZoneTrigger,
                                                    ::location::NewTriggerReply>
                            *streamer) {
                   return this->StreamedAddZoneTrigger(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_AddZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    AddZoneTrigger(::grpc::ServerContext * /*context*/,
                   const ::location::ZoneTrigger * /*request*/,
                   ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddZoneTrigger(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::ZoneTrigger,
                                    ::location::NewTriggerReply>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveZoneTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_RemoveZoneTrigger() {
      ::grpc::Service::MarkMethodStreamed(
          1,
          new ::grpc::internal::StreamedUnaryHandler<
              ::location::TriggerId, ::location::RemoveTriggerReply>(
              [this](::grpc::ServerContext *context,
                     ::grpc::ServerUnaryStreamer<::location::TriggerId,
                                                 ::location::RemoveTriggerReply>
                         *streamer) {
                return this->StreamedRemoveZoneTrigger(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_RemoveZoneTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    RemoveZoneTrigger(::grpc::ServerContext * /*context*/,
                      const ::location::TriggerId * /*request*/,
                      ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveZoneTrigger(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::TriggerId,
                                    ::location::RemoveTriggerReply>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetZoneTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_GetZoneTriggers() {
      ::grpc::Service::MarkMethodStreamed(
          2, new ::grpc::internal::StreamedUnaryHandler<
                 ::location::Empty, ::location::GetZoneTriggersReply>(
                 [this](::grpc::ServerContext *context,
                        ::grpc::ServerUnaryStreamer<
                            ::location::Empty, ::location::GetZoneTriggersReply>
                            *streamer) {
                   return this->StreamedGetZoneTriggers(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_GetZoneTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    GetZoneTriggers(::grpc::ServerContext * /*context*/,
                    const ::location::Empty * /*request*/,
                    ::location::GetZoneTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetZoneTriggers(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::Empty,
                                    ::location::GetZoneTriggersReply>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_AddProximityTrigger() {
      ::grpc::Service::MarkMethodStreamed(
          3,
          new ::grpc::internal::StreamedUnaryHandler<
              ::location::ProximityTrigger, ::location::NewTriggerReply>(
              [this](::grpc::ServerContext *context,
                     ::grpc::ServerUnaryStreamer<::location::ProximityTrigger,
                                                 ::location::NewTriggerReply>
                         *streamer) {
                return this->StreamedAddProximityTrigger(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_AddProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    AddProximityTrigger(::grpc::ServerContext * /*context*/,
                        const ::location::ProximityTrigger * /*request*/,
                        ::location::NewTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddProximityTrigger(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::ProximityTrigger,
                                    ::location::NewTriggerReply>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RemoveProximityTrigger : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_RemoveProximityTrigger() {
      ::grpc::Service::MarkMethodStreamed(
          4,
          new ::grpc::internal::StreamedUnaryHandler<
              ::location::TriggerId, ::location::RemoveTriggerReply>(
              [this](::grpc::ServerContext *context,
                     ::grpc::ServerUnaryStreamer<::location::TriggerId,
                                                 ::location::RemoveTriggerReply>
                         *streamer) {
                return this->StreamedRemoveProximityTrigger(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_RemoveProximityTrigger() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RemoveProximityTrigger(
        ::grpc::ServerContext * /*context*/,
        const ::location::TriggerId * /*request*/,
        ::location::RemoveTriggerReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRemoveProximityTrigger(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::TriggerId,
                                    ::location::RemoveTriggerReply>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProximityTriggers : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_GetProximityTriggers() {
      ::grpc::Service::MarkMethodStreamed(
          5, new ::grpc::internal::StreamedUnaryHandler<
                 ::location::Empty, ::location::GetProximityTriggersReply>(
                 [this](::grpc::ServerContext *context,
                        ::grpc::ServerUnaryStreamer<
                            ::location::Empty,
                            ::location::GetProximityTriggersReply> *streamer) {
                   return this->StreamedGetProximityTriggers(context, streamer);
                 }));
    }
    ~WithStreamedUnaryMethod_GetProximityTriggers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProximityTriggers(
        ::grpc::ServerContext * /*context*/,
        const ::location::Empty * /*request*/,
        ::location::GetProximityTriggersReply * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProximityTriggers(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::Empty,
                                    ::location::GetProximityTriggersReply>
            *server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_AddZoneTrigger<
      WithStreamedUnaryMethod_RemoveZoneTrigger<
          WithStreamedUnaryMethod_GetZoneTriggers<
              WithStreamedUnaryMethod_AddProximityTrigger<
                  WithStreamedUnaryMethod_RemoveProximityTrigger<
                      WithStreamedUnaryMethod_GetProximityTriggers<Service>>>>>>
      StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_AddZoneTrigger<
      WithStreamedUnaryMethod_RemoveZoneTrigger<
          WithStreamedUnaryMethod_GetZoneTriggers<
              WithStreamedUnaryMethod_AddProximityTrigger<
                  WithStreamedUnaryMethod_RemoveProximityTrigger<
                      WithStreamedUnaryMethod_GetProximityTriggers<Service>>>>>>
      StreamedService;
};

class TriggerProcessor final {
public:
  static constexpr char const *service_full_name() {
    return "location.TriggerProcessor";
  }
  class StubInterface {
  public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status
    ZoneTriggerEvent(::grpc::ClientContext *context,
                     const ::location::TriggerId &request,
                     ::location::Empty *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>
    AsyncZoneTriggerEvent(::grpc::ClientContext *context,
                          const ::location::TriggerId &request,
                          ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>(
          AsyncZoneTriggerEventRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>
    PrepareAsyncZoneTriggerEvent(::grpc::ClientContext *context,
                                 const ::location::TriggerId &request,
                                 ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>(
          PrepareAsyncZoneTriggerEventRaw(context, request, cq));
    }
    virtual ::grpc::Status
    ProximityTriggerEvent(::grpc::ClientContext *context,
                          const ::location::TriggerId &request,
                          ::location::Empty *response) = 0;
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>
    AsyncProximityTriggerEvent(::grpc::ClientContext *context,
                               const ::location::TriggerId &request,
                               ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>(
          AsyncProximityTriggerEventRaw(context, request, cq));
    }
    std::unique_ptr<
        ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>
    PrepareAsyncProximityTriggerEvent(::grpc::ClientContext *context,
                                      const ::location::TriggerId &request,
                                      ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReaderInterface<::location::Empty>>(
          PrepareAsyncProximityTriggerEventRaw(context, request, cq));
    }
    class async_interface {
    public:
      virtual ~async_interface() {}
      virtual void ZoneTriggerEvent(::grpc::ClientContext *context,
                                    const ::location::TriggerId *request,
                                    ::location::Empty *response,
                                    std::function<void(::grpc::Status)>) = 0;
      virtual void ZoneTriggerEvent(::grpc::ClientContext *context,
                                    const ::location::TriggerId *request,
                                    ::location::Empty *response,
                                    ::grpc::ClientUnaryReactor *reactor) = 0;
      virtual void ProximityTriggerEvent(
          ::grpc::ClientContext *context, const ::location::TriggerId *request,
          ::location::Empty *response, std::function<void(::grpc::Status)>) = 0;
      virtual void ProximityTriggerEvent(
          ::grpc::ClientContext *context, const ::location::TriggerId *request,
          ::location::Empty *response, ::grpc::ClientUnaryReactor *reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface *async() { return nullptr; }
    class async_interface *experimental_async() {
      return async();
    }

  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface<::location::Empty> *
    AsyncZoneTriggerEventRaw(::grpc::ClientContext *context,
                             const ::location::TriggerId &request,
                             ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::location::Empty> *
    PrepareAsyncZoneTriggerEventRaw(::grpc::ClientContext *context,
                                    const ::location::TriggerId &request,
                                    ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::location::Empty> *
    AsyncProximityTriggerEventRaw(::grpc::ClientContext *context,
                                  const ::location::TriggerId &request,
                                  ::grpc::CompletionQueue *cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface<::location::Empty> *
    PrepareAsyncProximityTriggerEventRaw(::grpc::ClientContext *context,
                                         const ::location::TriggerId &request,
                                         ::grpc::CompletionQueue *cq) = 0;
  };
  class Stub final : public StubInterface {
  public:
    Stub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
         const ::grpc::StubOptions &options = ::grpc::StubOptions());
    ::grpc::Status ZoneTriggerEvent(::grpc::ClientContext *context,
                                    const ::location::TriggerId &request,
                                    ::location::Empty *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::location::Empty>>
    AsyncZoneTriggerEvent(::grpc::ClientContext *context,
                          const ::location::TriggerId &request,
                          ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::Empty>>(
          AsyncZoneTriggerEventRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::location::Empty>>
    PrepareAsyncZoneTriggerEvent(::grpc::ClientContext *context,
                                 const ::location::TriggerId &request,
                                 ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::Empty>>(
          PrepareAsyncZoneTriggerEventRaw(context, request, cq));
    }
    ::grpc::Status ProximityTriggerEvent(::grpc::ClientContext *context,
                                         const ::location::TriggerId &request,
                                         ::location::Empty *response) override;
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::location::Empty>>
    AsyncProximityTriggerEvent(::grpc::ClientContext *context,
                               const ::location::TriggerId &request,
                               ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::Empty>>(
          AsyncProximityTriggerEventRaw(context, request, cq));
    }
    std::unique_ptr<::grpc::ClientAsyncResponseReader<::location::Empty>>
    PrepareAsyncProximityTriggerEvent(::grpc::ClientContext *context,
                                      const ::location::TriggerId &request,
                                      ::grpc::CompletionQueue *cq) {
      return std::unique_ptr<
          ::grpc::ClientAsyncResponseReader<::location::Empty>>(
          PrepareAsyncProximityTriggerEventRaw(context, request, cq));
    }
    class async final : public StubInterface::async_interface {
    public:
      void ZoneTriggerEvent(::grpc::ClientContext *context,
                            const ::location::TriggerId *request,
                            ::location::Empty *response,
                            std::function<void(::grpc::Status)>) override;
      void ZoneTriggerEvent(::grpc::ClientContext *context,
                            const ::location::TriggerId *request,
                            ::location::Empty *response,
                            ::grpc::ClientUnaryReactor *reactor) override;
      void ProximityTriggerEvent(::grpc::ClientContext *context,
                                 const ::location::TriggerId *request,
                                 ::location::Empty *response,
                                 std::function<void(::grpc::Status)>) override;
      void ProximityTriggerEvent(::grpc::ClientContext *context,
                                 const ::location::TriggerId *request,
                                 ::location::Empty *response,
                                 ::grpc::ClientUnaryReactor *reactor) override;

    private:
      friend class Stub;
      explicit async(Stub *stub) : stub_(stub) {}
      Stub *stub() { return stub_; }
      Stub *stub_;
    };
    class async *async() override {
      return &async_stub_;
    }

  private:
    std::shared_ptr<::grpc::ChannelInterface> channel_;
    class async async_stub_ {
      this
    };
    ::grpc::ClientAsyncResponseReader<::location::Empty> *
    AsyncZoneTriggerEventRaw(::grpc::ClientContext *context,
                             const ::location::TriggerId &request,
                             ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::Empty> *
    PrepareAsyncZoneTriggerEventRaw(::grpc::ClientContext *context,
                                    const ::location::TriggerId &request,
                                    ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::Empty> *
    AsyncProximityTriggerEventRaw(::grpc::ClientContext *context,
                                  const ::location::TriggerId &request,
                                  ::grpc::CompletionQueue *cq) override;
    ::grpc::ClientAsyncResponseReader<::location::Empty> *
    PrepareAsyncProximityTriggerEventRaw(::grpc::ClientContext *context,
                                         const ::location::TriggerId &request,
                                         ::grpc::CompletionQueue *cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ZoneTriggerEvent_;
    const ::grpc::internal::RpcMethod rpcmethod_ProximityTriggerEvent_;
  };
  static std::unique_ptr<Stub>
  NewStub(const std::shared_ptr<::grpc::ChannelInterface> &channel,
          const ::grpc::StubOptions &options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
  public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status
    ZoneTriggerEvent(::grpc::ServerContext *context,
                     const ::location::TriggerId *request,
                     ::location::Empty *response);
    virtual ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext *context,
                          const ::location::TriggerId *request,
                          ::location::Empty *response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ZoneTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_ZoneTriggerEvent() { ::grpc::Service::MarkMethodAsync(0); }
    ~WithAsyncMethod_ZoneTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZoneTriggerEvent(::grpc::ServerContext * /*context*/,
                                    const ::location::TriggerId * /*request*/,
                                    ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestZoneTriggerEvent(
        ::grpc::ServerContext *context, ::location::TriggerId *request,
        ::grpc::ServerAsyncResponseWriter<::location::Empty> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ProximityTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithAsyncMethod_ProximityTriggerEvent() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ProximityTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProximityTriggerEvent(
        ::grpc::ServerContext *context, ::location::TriggerId *request,
        ::grpc::ServerAsyncResponseWriter<::location::Empty> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ZoneTriggerEvent<
      WithAsyncMethod_ProximityTriggerEvent<Service>>
      AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_ZoneTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_ZoneTriggerEvent() {
      ::grpc::Service::MarkMethodCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::location::TriggerId,
                                                        ::location::Empty>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::TriggerId *request,
                        ::location::Empty *response) {
                   return this->ZoneTriggerEvent(context, request, response);
                 }));
    }
    void SetMessageAllocatorFor_ZoneTriggerEvent(
        ::grpc::MessageAllocator<::location::TriggerId, ::location::Empty>
            *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler<::location::TriggerId,
                                                         ::location::Empty> *>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ZoneTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZoneTriggerEvent(::grpc::ServerContext * /*context*/,
                                    const ::location::TriggerId * /*request*/,
                                    ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    ZoneTriggerEvent(::grpc::CallbackServerContext * /*context*/,
                     const ::location::TriggerId * /*request*/,
                     ::location::Empty * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithCallbackMethod_ProximityTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithCallbackMethod_ProximityTriggerEvent() {
      ::grpc::Service::MarkMethodCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::location::TriggerId,
                                                        ::location::Empty>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::location::TriggerId *request,
                        ::location::Empty *response) {
                   return this->ProximityTriggerEvent(context, request,
                                                      response);
                 }));
    }
    void SetMessageAllocatorFor_ProximityTriggerEvent(
        ::grpc::MessageAllocator<::location::TriggerId, ::location::Empty>
            *allocator) {
      ::grpc::internal::MethodHandler *const handler =
          ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler<::location::TriggerId,
                                                         ::location::Empty> *>(
          handler)
          ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ProximityTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    ProximityTriggerEvent(::grpc::CallbackServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) {
      return nullptr;
    }
  };
  typedef WithCallbackMethod_ZoneTriggerEvent<
      WithCallbackMethod_ProximityTriggerEvent<Service>>
      CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ZoneTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_ZoneTriggerEvent() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ZoneTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZoneTriggerEvent(::grpc::ServerContext * /*context*/,
                                    const ::location::TriggerId * /*request*/,
                                    ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ProximityTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithGenericMethod_ProximityTriggerEvent() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ProximityTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ZoneTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_ZoneTriggerEvent() { ::grpc::Service::MarkMethodRaw(0); }
    ~WithRawMethod_ZoneTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZoneTriggerEvent(::grpc::ServerContext * /*context*/,
                                    const ::location::TriggerId * /*request*/,
                                    ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestZoneTriggerEvent(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ProximityTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawMethod_ProximityTriggerEvent() { ::grpc::Service::MarkMethodRaw(1); }
    ~WithRawMethod_ProximityTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProximityTriggerEvent(
        ::grpc::ServerContext *context, ::grpc::ByteBuffer *request,
        ::grpc::ServerAsyncResponseWriter<::grpc::ByteBuffer> *response,
        ::grpc::CompletionQueue *new_call_cq,
        ::grpc::ServerCompletionQueue *notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response,
                                         new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ZoneTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_ZoneTriggerEvent() {
      ::grpc::Service::MarkMethodRawCallback(
          0, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->ZoneTriggerEvent(context, request, response);
                 }));
    }
    ~WithRawCallbackMethod_ZoneTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ZoneTriggerEvent(::grpc::ServerContext * /*context*/,
                                    const ::location::TriggerId * /*request*/,
                                    ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    ZoneTriggerEvent(::grpc::CallbackServerContext * /*context*/,
                     const ::grpc::ByteBuffer * /*request*/,
                     ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ProximityTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithRawCallbackMethod_ProximityTriggerEvent() {
      ::grpc::Service::MarkMethodRawCallback(
          1, new ::grpc::internal::CallbackUnaryHandler<::grpc::ByteBuffer,
                                                        ::grpc::ByteBuffer>(
                 [this](::grpc::CallbackServerContext *context,
                        const ::grpc::ByteBuffer *request,
                        ::grpc::ByteBuffer *response) {
                   return this->ProximityTriggerEvent(context, request,
                                                      response);
                 }));
    }
    ~WithRawCallbackMethod_ProximityTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor *
    ProximityTriggerEvent(::grpc::CallbackServerContext * /*context*/,
                          const ::grpc::ByteBuffer * /*request*/,
                          ::grpc::ByteBuffer * /*response*/) {
      return nullptr;
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ZoneTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_ZoneTriggerEvent() {
      ::grpc::Service::MarkMethodStreamed(
          0,
          new ::grpc::internal::StreamedUnaryHandler<::location::TriggerId,
                                                     ::location::Empty>(
              [this](::grpc::ServerContext *context,
                     ::grpc::ServerUnaryStreamer<::location::TriggerId,
                                                 ::location::Empty> *streamer) {
                return this->StreamedZoneTriggerEvent(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_ZoneTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ZoneTriggerEvent(::grpc::ServerContext * /*context*/,
                                    const ::location::TriggerId * /*request*/,
                                    ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedZoneTriggerEvent(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::TriggerId, ::location::Empty>
            *server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ProximityTriggerEvent : public BaseClass {
  private:
    void BaseClassMustBeDerivedFromService(const Service * /*service*/) {}

  public:
    WithStreamedUnaryMethod_ProximityTriggerEvent() {
      ::grpc::Service::MarkMethodStreamed(
          1,
          new ::grpc::internal::StreamedUnaryHandler<::location::TriggerId,
                                                     ::location::Empty>(
              [this](::grpc::ServerContext *context,
                     ::grpc::ServerUnaryStreamer<::location::TriggerId,
                                                 ::location::Empty> *streamer) {
                return this->StreamedProximityTriggerEvent(context, streamer);
              }));
    }
    ~WithStreamedUnaryMethod_ProximityTriggerEvent() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status
    ProximityTriggerEvent(::grpc::ServerContext * /*context*/,
                          const ::location::TriggerId * /*request*/,
                          ::location::Empty * /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProximityTriggerEvent(
        ::grpc::ServerContext *context,
        ::grpc::ServerUnaryStreamer<::location::TriggerId, ::location::Empty>
            *server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ZoneTriggerEvent<
      WithStreamedUnaryMethod_ProximityTriggerEvent<Service>>
      StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ZoneTriggerEvent<
      WithStreamedUnaryMethod_ProximityTriggerEvent<Service>>
      StreamedService;
};

} // namespace location

#endif // GRPC_location_5fsubscription_2eproto__INCLUDED
